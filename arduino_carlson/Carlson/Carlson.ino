// Carlson: Chute Deployment and Logging System
// 
// This script will boot Carlson, lock nose-cone after successful
// initialization, record gyro / accel / temperature / microphone sensor
// readings during rocket flight, and deploy chute at altitude. 
//
// Chute deployment occurs after the Z accelerometer consistently measures
// less than -0.9g of downward force for n seconds.
//
// Code by: Benjamin Shanahan & Isaiah Brand

#include "Carlson.h"

void setup()
{

    if (SERIAL)
        Serial.begin(BAUD_RATE);
    Wire.begin();
    time = millis();

    // initialize SD card logging
    initializeSDLogging();

    // initialize arduino hardware
    pinMode(MICROPHONE_PIN, INPUT);
    pinMode(BLUE_LED_PIN, OUTPUT);
    pinMode(GREEN_LED_PIN, OUTPUT);
    pinMode(DETONATION_RELAY_PIN, OUTPUT);
    accelgyro.initialize();
    setCalibratedOffsets();  // set MPU6050 offsets

    // open logfile
    logFile = SD.open(logFileName, FILE_WRITE);

    if (SERIAL)
        Serial.println("Carlson initialization successful.");

    delay(1);

}

void loop()
{

    loopTimer = millis();

    // collect readings from hardware
    accelgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
    temperature = accelgyro.getTemperature();
    microphone  = getMicrophoneAmplitude();
    timestamp   = millis();  // timestamp

    // determine timestep for integration
    timePrev = time;
    time     = millis();
    timeStep = double(time - timePrev) / 1000; // convert timestep to seconds

    // integration of gyroscopic angular acceleration values
    if (!firstRun)
    {
        grx = grx + (timeStep * gsx);
        gry = gry + (timeStep * gsy);
        grz = grz + (timeStep * gsz);
    }

    printSensorValues();  // if desired

    writeToLog(timestamp, 
               ax, ay, az,     // rot from acceleration
               grx, gry, grz,  // rot from gyro
               temperature, microphone);

    if (PRINT_LOOP_TIMER)
        Serial.println("loop timer: " + String(millis()-loopTimer) + " ms");

    if (firstRun) firstRun = false;
    
}

// Write data to logfile on SD card
int writeToLog(uint32_t ts,
                float ax, float ay, float az, 
                float gx, float gy, float gz, 
                float temp, float mic)
{

    String strLine = String(ts)+",\t"+
                        String(ax)+",\t" + String(ay)+",\t" + String(az)+",\t" + 
                        String(gx)+",\t" + String(gy)+",\t" + String(gz)+",\t" + 
                        String(temp)+",\t" + String(mic);

    logFile.println(strLine);  // log to file
    
    if (flushCounter == N_ITERS_BEFORE_FLUSH) {
        // to increase speed, we only flush to file once every N_ITERS_BEFORE_FLUSH loops
        logFile.flush();
        flushCounter = 0;
    }
    
    flushCounter += 1;

}

// Write offsets to MPU6050
void setCalibratedOffsets()
{

    accelgyro.setXAccelOffset(OFFSET_ACCEL_X);
    accelgyro.setYAccelOffset(OFFSET_ACCEL_Y);
    accelgyro.setZAccelOffset(OFFSET_ACCEL_Z);  
    accelgyro.setXGyroOffset(OFFSET_GYRO_X);
    accelgyro.setYGyroOffset(OFFSET_GYRO_Y);
    accelgyro.setZGyroOffset(OFFSET_GYRO_Z);

}

// Initialize SD card logging functionality
// Code by Isaiah Brand
//
// Opens "counter.txt" on SD card, reads the integer contained in the file,
// increments it, and writes the incremented number to the file. This number
// is then appended to the in-flight logfile generated by Carlson (i.e. 
// "LOG_4.txt"). Afterwards, "counter.txt" is closed, and the new logfile is
// opened and available for writing data.
void initializeSDLogging()
{

    // open counterFile and read in the number
    if (!SD.begin(CHIP_SELECT_PIN))
    {
        if (SERIAL)
            Serial.println("Card initialization failed!");

        // TODO: make this error more aggressive; fail to lock nose cone
        return;
    }
    incrementFile = SD.open(incrementFileName);

    if (incrementFile)
    {
        logNumber = incrementFile.parseInt();
        incrementFile.close();
        SD.remove(incrementFileName);
    }

    // open the counterFile as WRITE and write the next number
    incrementFile = SD.open(incrementFileName, FILE_WRITE);
    if (incrementFile)
    {
        incrementFile.print(logNumber + 1);
        incrementFile.close();
    }

    // turn the logNumber into a fileName and open it to log to
    if (logNumber > 0)
        logFileName = "log_" + String(logNumber) + ".txt";

}

// Print values from sensors to Serial console
void printSensorValues()
{

    if (SERIAL && PRINT_SENSOR_VALUES)
    {
        Serial.print("A:\t");
        Serial.print(String(asx) + "\t");
        Serial.print(String(asy) + "\t");
        Serial.print(String(asz) + "\t\t");
        Serial.print("G:\t");
        Serial.print(String(grx) + "\t");
        Serial.print(String(gry) + "\t");
        Serial.print(String(grz) + "\t\t");
        Serial.print("T:\t");
        Serial.print(String(temperature) + "\t");
        Serial.print("M:\t");
        Serial.print(String(microphone) + "V");
        Serial.println();
    }

}

// calculate amplitude of sampled sound
double getMicrophoneAmplitude()
{

    // reset dynamic variables
    minMicSample = 1024;
    maxMicSample = 0;

    for (m = 0; m < N_ITERS_MIC_SAMPLE; m++)
    {

        sample = analogRead(MICROPHONE_PIN);

        // if current microphone reading is greater than or less than
        // max or min, respectively, replace those values
        if (sample < MAXIMUM_ANALOG_IN_VALUE)  // reject impossible samples
        {
            if (sample > maxMicSample)
                maxMicSample = sample;
            else if (sample < minMicSample)
                minMicSample = sample;
        }

    }

    // compute sound amplitude in volts
    micDiff = double(maxMicSample - minMicSample);
    return (micDiff * 5.0) / MAXIMUM_ANALOG_IN_VALUE;  // convert to volts

}