// Carlson: Chute Deployment and Logging System
// 
// This script will boot Carlson, lock nose-cone after successful
// initialization, record gyro / accel / temperature / microphone sensor
// readings during rocket flight, and deploy chute at altitude. 
//
// Chute deployment occurs after the Z accelerometer consistently measures
// less than -0.9g of downward force for n seconds.
//
// Code by: Benjamin Shanahan & Isaiah Brand

#include "Carlson.h"

void setup()
{

    if (SERIAL)
        Serial.begin(BAUD_RATE);
    Wire.begin();
    time = millis();

    // initialize arduino hardware
    pinMode(MICROPHONE_PIN, INPUT);
    pinMode(BLUE_LED_PIN, OUTPUT); digitalWrite(BLUE_LED_PIN, LOW);
    pinMode(GREEN_LED_PIN, OUTPUT);
    pinMode(RELAY_DETONATION_PIN, OUTPUT);
    // pinMode(RELAY_INTERRUPT_PIN, INPUT);

    // attach interrupt for manual relay trigger from RC
    // when digital pin goes high, call the rising function
    attachInterrupt(digitalPinToInterrupt(RELAY_INTERRUPT_PIN), rising, RISING);

    accelgyro.initialize();
    setCalibratedOffsets();  // set MPU6050 offsets

    // initialize SD card logging
    if (!initializeSDLogging())
        blinkError();  // initialization failed!

    // open logfile
    logFile = SD.open(logFileName, FILE_WRITE);

    if (SERIAL)
        Serial.println("Carlson initialization successful.");

    // don't fire the chute ejection charge!
    digitalWrite(RELAY_DETONATION_PIN, LOW);  // OFF
    
    // turn blue LED solid to indicate that Carlson is ready to 
    // arm and launch
    if (digitalRead(RELAY_DETONATION_PIN) != LOW)  // double check
        blinkError();

    // update flight flags
    flightFlag = FLAG_DEFAULT;

    // do arming blink and wait for RC transmitter to go mid-range PWM
    blockUntilManualChuteTriggerReady();

    delay(1);

}

void loop()
{

    loopTimer = millis();

    // collect readings from hardware
    // NOTE: due to rocket orientation, the MPU's x and z axes
    //       are switched
    accelgyro.getMotion6(&az, &ay, &ax, &gz, &gy, &gx);
    temperature = accelgyro.getTemperature();
    microphone  = getMicrophoneAmplitude();
    timestamp   = millis();  // timestamp

    // determine timestep for integration
    timePrev = time;
    time     = millis();
    timeStep = double(time - timePrev) * 0.001; // convert timestep to seconds

    // scale sensor readings
    asx = ax * accelScale;
    asy = ay * accelScale;
    asz = az * accelScale;
    gsx = gx * gyroScale;
    gsy = gy * gyroScale;
    gsz = gz * gyroScale;

    // integration of gyroscopic angular acceleration values
    if (!firstRun)
    {
        grx = grx + (timeStep * gsx);
        gry = gry + (timeStep * gsy);
        grz = grz + (timeStep * gsz);
    }

    printSensorValues();  // if desired

    checkForChuteDeploy();  // deploy chute if it's time

    writeToCard(timestamp, 
               asx, asy, asz,     // rot from acceleration
               gsx, gsy, gsz,  // rot from gyro
               temperature, microphone,
               flightFlag);

    if (PRINT_LOOP_TIMER)
        Serial.println("loop timer: " + String(millis()-loopTimer) + " ms");

    if (firstRun) firstRun = false;
    
}

// Write data to logfile on SD card
int writeToCard(uint32_t ts,
                float accelX, float accelY, float accelZ, 
                float gyroX, float gyroY, float gyroZ, 
                float temp, float mic, int flag)
{

    digitalWrite(GREEN_LED_PIN, LOW);  // flush counter off

    String strLine = String(ts)+",\t"+
                        String(accelX)+",\t" + String(accelY)+",\t" + String(accelZ)+",\t" + 
                        String(gyroX)+",\t" + String(gyroY)+",\t" + String(gyroZ)+",\t" + 
                        String(temp)+",\t" + String(mic)+",\t" + String(flag);

    logFile.println(strLine);  // log to file
    
    if (flushCounter == N_ITERS_BEFORE_FLUSH) {
        // to increase speed, we only flush to file once every N_ITERS_BEFORE_FLUSH loops
        logFile.flush();
        flushCounter = 0;
        digitalWrite(GREEN_LED_PIN, HIGH);  // visualize flush
    }
    
    flushCounter += 1;

}

// Write offsets to MPU6050
void setCalibratedOffsets()
{

    accelgyro.setXAccelOffset(OFFSET_ACCEL_X);
    accelgyro.setYAccelOffset(OFFSET_ACCEL_Y);
    accelgyro.setZAccelOffset(OFFSET_ACCEL_Z);  
    accelgyro.setXGyroOffset(OFFSET_GYRO_X);
    accelgyro.setYGyroOffset(OFFSET_GYRO_Y);
    accelgyro.setZGyroOffset(OFFSET_GYRO_Z);

}

// Initialize SD card logging functionality
// Code by Isaiah Brand
//
// Opens "counter.txt" on SD card, reads the integer contained in the file,
// increments it, and writes the incremented number to the file. This number
// is then appended to the in-flight logfile generated by Carlson (i.e. 
// "LOG_4.txt"). Afterwards, "counter.txt" is closed, and the new logfile is
// opened and available for writing data.
bool initializeSDLogging()
{

    // open counterFile and read in the number
    if (!SD.begin(CHIP_SELECT_PIN))
    {
        if (SERIAL)
            Serial.println("Card initialization failed!");
        return false;
    }
    digitalWrite(BLUE_LED_PIN, HIGH);
    incrementFile = SD.open(incrementFileName);

    if (incrementFile)
    {
        logNumber = incrementFile.parseInt();
        incrementFile.close();
        SD.remove(incrementFileName);
    }

    // open the counterFile as WRITE and write the next number
    incrementFile = SD.open(incrementFileName, FILE_WRITE);
    if (incrementFile)
    {
        incrementFile.print(logNumber + 1);
        incrementFile.close();
    }

    // turn the logNumber into a fileName and open it to log to
    if (logNumber > 0)
        logFileName = "log_" + String(logNumber) + ".txt";

    return true;

}

// Print values from sensors to Serial console
void printSensorValues()
{

    if (SERIAL && PRINT_SENSOR_VALUES)
    {
        Serial.print("A:\t");
        Serial.print(String(asx) + "\t");
        Serial.print(String(asy) + "\t");
        Serial.print(String(asz) + "\t\t");
        Serial.print("G:\t");
        Serial.print(String(gsx) + "\t");
        Serial.print(String(gsy) + "\t");
        Serial.print(String(gsz) + "\t\t");
        Serial.print("T:\t");
        Serial.print(String(temperature) + "\t");
        Serial.print("M:\t");
        Serial.print(String(microphone) + "V" + "\t");
        Serial.print("flag:\t");
        Serial.print(String(flightFlag));
        Serial.println();
    }

}

// calculate amplitude of sampled sound
double getMicrophoneAmplitude()
{

    // reset dynamic variables
    minMicSample = 1024;
    maxMicSample = 0;

    for (m = 0; m < N_ITERS_MIC_SAMPLE; m++)
    {

        sample = analogRead(MICROPHONE_PIN);

        // if current microphone reading is greater than or less than
        // max or min, respectively, replace those values
        if (sample < MAXIMUM_ANALOG_IN_VALUE)  // reject impossible samples
        {
            if (sample > maxMicSample)
                maxMicSample = sample;
            else if (sample < minMicSample)
                minMicSample = sample;
        }

    }

    // compute sound amplitude in volts
    micDiff = double(maxMicSample - minMicSample);
    return (micDiff * 5.0) / MAXIMUM_ANALOG_IN_VALUE;  // convert to volts

}

void checkForChuteDeploy()
{

    // check for autonomous chute deploy
    // TODO ...

    // check for manual chute deploy
    if (pwmValue > CHUTE_TRIGGER_PWM)
    {
        digitalWrite(RELAY_DETONATION_PIN, HIGH);  // close relay
        if (deployCounter == 0)
            flightFlag += FLAG_CARLSON_CHUTE_DEPLOY;  
        Serial.println("DEPLOYING CHUTE");
        deployCounter++;
    }
    else
    {
        // allow manual deploy to be canceled
        digitalWrite(RELAY_DETONATION_PIN, LOW);  // open relay
    }

}

void blinkError()
{
    for (;;)
    {
        digitalWrite(BLUE_LED_PIN, HIGH);
        delay(ERROR_BLINK_DELAY);
        digitalWrite(BLUE_LED_PIN, LOW);
        delay(ERROR_BLINK_DELAY);
    }
}

void blockUntilManualChuteTriggerReady()
{

    if (SERIAL)
        Serial.println("Ready to arm\nMove RC input to MIDDLE position");

    while(pwmValue < CHUTE_ARM_PWM-100 || pwmValue > CHUTE_ARM_PWM+100)
    {
        digitalWrite(BLUE_LED_PIN, HIGH);
        delay(ARM_READY_BLINK_DELAY);
        digitalWrite(BLUE_LED_PIN, LOW);
        delay(ARM_READY_BLINK_DELAY);
    }

    if (SERIAL)
        Serial.println("Move RC input to OFF position");    

    while(pwmValue > CHUTE_OFF_PWM)
    {
        digitalWrite(BLUE_LED_PIN, HIGH);
        delay(ARM_READY_BLINK_DELAY);
        digitalWrite(BLUE_LED_PIN, LOW);
        delay(ARM_READY_BLINK_DELAY);
    }
    
    if (SERIAL)
        Serial.println("Relay is ARMED");

    digitalWrite(BLUE_LED_PIN, HIGH);

}

// get PWM value from interrupt pin connected to RF receiver
void rising() 
{

    attachInterrupt(digitalPinToInterrupt(RELAY_INTERRUPT_PIN), falling, FALLING);
    prevTime = micros();

}
void falling()
{

    attachInterrupt(digitalPinToInterrupt(RELAY_INTERRUPT_PIN), rising, RISING);
    pwmValue = micros() - prevTime;

}